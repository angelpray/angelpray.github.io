

<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="JavaScript编程"/>




  <meta name="keywords" content="JavaScript," />





  <link rel="alternate" href="/default" title="Janro-Cheung">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://angelpray.github.io/2018/10/28/learn JS/"/>


<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript编程">
<meta property="og:url" content="https://angelpray.github.io/2018/10/28/learn JS/index.html">
<meta property="og:site_name" content="Janro-Cheung">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://picf6pcrc.bkt.clouddn.com/2018-11-17-23-25-36.png">
<meta property="og:updated_time" content="2018-11-28T07:04:58.501Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript编程">
<meta name="twitter:image" content="http://picf6pcrc.bkt.clouddn.com/2018-11-17-23-25-36.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> JavaScript编程 - Janro-Cheung </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Janro-Cheung</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                所有文章
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                关于
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          JavaScript编程
        
      </h1>

      <time class="post-time">
          10月 28 2018
      </time>
    </header>



    
            <div class="post-content">
            <p><img src="http://picf6pcrc.bkt.clouddn.com/2018-11-17-23-25-36.png" alt="2018-11-17-23-25-36"><br><a id="more"></a></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="数字到字符串"><a href="#数字到字符串" class="headerlink" title="数字到字符串"></a>数字到字符串</h3><ol>
<li><code>toString(radix)：</code>进制转换，十进制转其他进制。</li>
<li><code>toFixed(n)：</code>小数点后指定位数。</li>
<li><code>toExponential(n):</code>使用指数计数法,小数点前只有一位，指定小数点后的位数。</li>
<li><code>toPrecision(n)：</code>指定有效位数，如果有效数字的位数少于整数部分，会转换成指数计数。<br>(以上方法都会进行四舍五入或填充0)</li>
</ol>
<h3 id="字符串到数字"><a href="#字符串到数字" class="headerlink" title="字符串到数字"></a>字符串到数字</h3><ol>
<li>Number(n)：转换成整数或浮点数直接量。不能出现非法的尾随字符。</li>
<li>parseInt(number,radix)：只解析整数，提供第二参数，则以这个指定的进制转换基数。其他进制转换成十进制。会跳过空格，忽略后面的非数字内容。</li>
<li>parseFloat(number):解析浮点数和整数，没有进制参数。</li>
</ol>
<h3 id="对象转换为原始值"><a href="#对象转换为原始值" class="headerlink" title="对象转换为原始值"></a>对象转换为原始值</h3><ol>
<li>对象转换成布尔值：所有对象(不包含null)都是true。</li>
<li>对象转换成字符串：首先toString(),没有则使用valueOf()，否则错误。</li>
<li>对象转换成数字：先valueOf(),没有则使用toString()，否则错误。</li>
</ol>
<h2 id="属性查询和设置"><a href="#属性查询和设置" class="headerlink" title="属性查询和设置"></a>属性查询和设置</h2><ol>
<li><p>使用.或方括号来获取属性值。.右侧是一个简单标识符，[]内必须是一个计算结果为字符串的表达式。</p>
</li>
<li><p>以方括号的方式查询属性看起来更像数组，只是使用字符串索引而不是数字索引，这种数组就是<em>关联数组</em>，也叫散列，映射，字典。</p>
</li>
<li><p>查询一个不存在的属性会返回undefined。</p>
</li>
</ol>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete expression</code>:expression是属性访问表达式。</p>
<ol>
<li>不能删除那些可配置性为false的属性。</li>
<li>不能删除通过变量声明和函数声明创建的全局对象的属性。</li>
</ol>
<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><p>4种方法检测属性：</p>
<ol>
<li>in运算符：继承属性或自有属性都返回true</li>
<li>hasOwnPropery(str)方法：自有属性才返回true</li>
<li>propertyIsEnumerable(str)方法：自有属性并且可枚举返回true</li>
<li>属性查询：通过.或方括号查询属性，判断是否全等undefined</li>
</ol>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><p>3中方法枚举属性</p>
<ol>
<li>for/in循环：for(key in obj) {obj[key]}返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中<br>既包括存在于实例中的属性，也包括存在于原型中的属性.</li>
<li>Object.keys(obj)：返回对象中可枚举并且是自有属性的数组</li>
<li>Object.getOwnPropertyNames(obj):返回对象中所有的自有属性，而不仅仅是可枚举属性</li>
</ol>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><h3 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h3><p>getter和setter定义的属性称为“存取器属性”，同时具有setter方法和getter方法，则具有读/写属性，否则只具备其中之一。<br>getter：当尝试查询get属性时，将调用get函数。<br>setter：当尝试设置set属性时，将调用set函数。</p>
<h3 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h3><ol>
<li>get,set,configurable,enumerable<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里是year而不是_year</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><ol>
<li><p>[[value]], [[writable]], [[configurable]], [[enumerable]]<br>默认情况，直接创建的对象，除了value是undefined，全都是true<br>使用Object.defineProperty方法创建的属性都是false，undefined</p>
<h3 id="读取特性"><a href="#读取特性" class="headerlink" title="读取特性"></a>读取特性</h3></li>
<li><p>Object.getOwnPropertyDescriptor(obj, prop)</p>
</li>
<li>Object.getOwnPropertyDescriptors(obj)</li>
</ol>
<h3 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h3><ol>
<li>Object.defineProperty(obj, prop, {attrib})</li>
<li>Object.defineProperties(obj, {prop: {attrib},})</li>
</ol>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><ol>
<li>Object.getPrototypeOf(obj)：返回obj的原型对象</li>
<li>isPrototype(obj): 检测一个对象是否是另一个对象的原型（类似instanceof元素符<em>运算符不用驼峰写法，而方法则需要</em>）</li>
<li>o.constructor返回创建实例对象的Object的构造函数</li>
<li>使用instanceof来进行对象类型检测<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3></li>
</ol>
<p>表示对象的类型信息。略。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>表示是否可以给对象添加新属性。默认都是显式可扩展的。</p>
<ol>
<li>Object.isExtensible():判断该对象是否可扩展。</li>
<li>Object.preventExtensions():设置对象不可扩展。不可逆转。</li>
<li>Object.seal():类似preventExtensions(),还将设置所有的自由属性为不可配置，封闭。不可逆转。</li>
<li>Object.freeze()：类似seal()，还将设置所有的数据属性为只读，冻结。</li>
<li>isSeal(),isFrozen()：检测是否封闭，冻结。</li>
</ol>
<h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>对象序列化（serialization）指将对象的状态转换为字符串，也可以字符串还原为对象。</p>
<ol>
<li>JSON.stringify():序列化</li>
<li>JSON.parse():还原<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1></li>
</ol>
<h2 id="Function-prototype-apply-thisArg-argsArray"><a href="#Function-prototype-apply-thisArg-argsArray" class="headerlink" title="Function.prototype.apply(thisArg, argsArray)"></a>Function.prototype.apply(thisArg, argsArray)</h2><p><em>apply()方法调用一个函数，其具有一个指定的this值和一个数组(或者类数组对象)作为的参数。</em><br><strong>apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表。</strong><br>返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p>
<h2 id="Function-prototype-call-thisArg-arg1-arg2…"><a href="#Function-prototype-call-thisArg-arg1-arg2…" class="headerlink" title="Function.prototype.call(thisArg, arg1, arg2…)"></a>Function.prototype.call(thisArg, arg1, arg2…)</h2><p><em>call()方法调用一个函数，其具有一个指定的this值和分别提供的参数(参数列表)。</em><br>返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p>
<h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><p><em>bind()方法创建一个新的函数，这个新函数被调用时，新函数的this设置为提供的值，新函数的参数列表前几项设置为提供的参数列表。</em><br>返回由指定的this值和初始化参数改造的原函数拷贝。<br>**区别apply，call，返回原函数拷贝而不是原函数的返回值。</p>
<h2 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h2><p>表示包含当前正在执行的函数</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li><p>简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。</p>
</li>
<li><p>当闭包被返回或者被调用的时候，一定要注意this的值，这个值一般都是指向window的。</p>
</li>
</ol>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="对象以及原型"><a href="#对象以及原型" class="headerlink" title="对象以及原型"></a>对象以及原型</h2><ol>
<li><p>通过类可以创建任意多个具有相同属性和方法的对象，ECMAScript 中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p>
</li>
<li><p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”</p>
</li>
<li><p>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生的，比如Array，Date等，也可以是开发人员自定义的类型。</p>
</li>
<li><p>我们创建的每个函数都有一个prototype原型属性，这个属性是一个指针，指向一个对象。<strong>prototype就是通过调用构造函数而创建的对象实例的原型对象。包含特定类型的实例共享的属性和方法</strong>。</p>
</li>
<li><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。</p>
</li>
<li><p>原型对象获得一个constructor指向构造函数。</p>
</li>
<li><p>当调用构造函数创建一个实例后，该实例的内部有一个指针，指向构造函数的原型对象。</p>
</li>
<li><p>每当代码读取某个对象的某个属性，都会执行一次搜索，先从对象实例开始，再到原型对象。</p>
</li>
<li><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。（基本值而言，引用类型则会改变）</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>许多OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。</p>
</li>
<li><p>由于函数没有签名，在ECMAScript 中无法实现接口继承。ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
</li>
<li><p>构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
</li>
<li><p>我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针。</p>
</li>
<li><p>原型链：：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
</li>
<li><p>所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因</p>
</li>
<li><p>确定原型和实例的关系<br>第一种方式是使用instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。<br>第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true。</p>
</li>
<li><p>给原型添加方法的代码一定要放在替换原型的语句之后</p>
</li>
<li><p>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。</p>
</li>
<li><p>原型链的问题：最主要的问题来自包含引用类型值的原型。原先的实例属性也就顺理成章地变成了现在的原型属性了。<br>原型链的第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
</li>
<li><p>借用构造函数</p>
</li>
</ol>
<h1 id="Array-API"><a href="#Array-API" class="headerlink" title="Array API"></a>Array API</h1><ol>
<li>创建数组的方式：Array构造函数、数组字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> <span class="built_in">Array</span>(length); <span class="comment">// legnth表示长度，可给定一个数字</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>); <span class="comment">//这样可以直接创建数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.数组的项数保存在其length 属性中，这个属性始终会返回0 或更大的值。数组的length 属性很有特点——它不是只读的。通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</span><br><span class="line">color.length = <span class="number">1</span>;</span><br><span class="line">color[<span class="number">1</span>]; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">color[color.length] = <span class="string">"green"</span>;</span><br><span class="line">color[color.length<span class="number">-1</span>]; <span class="comment">//green</span></span><br></pre></td></tr></table></figure></p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p><code>Array.isArray(array);</code></p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>数组转字符串：<code>toString()</code>，返回由每个值的字符串拼接成以逗号分隔的字符串。<br>数组转字符串：<code>join(分隔符)</code>,可以使用不同的分隔符来构建这个字符串。<br>注意：如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。</p>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。<br>插入：push(str1,str2,)，插入若干项，返回修改后数组的长度。<br>移除：pop(),移除最后一项，返回移除项</p>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>队列数据结构的访问规则是FIFO（First-In-First-Out，先进先出）。<br>插入：push<br>移除：shift(),移除数组中第一项并返回该项，同时将数组长度减1。</p>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>反序排列：reverse();返回排序之后的数组<br>灵活排序：sort(fn(a, b)),默认按什序排列数组，将元素转为字符串再进行比较，即使是数值也比较的是字符串。为了更灵活的比较，可以使用比较函数，比较函数接收两个参数，比较函数通过大于0，小于0，等于0来排序。返回的是排序之后的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 什序 asc</span></span><br><span class="line"><span class="keyword">let</span> compare = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 降序 desc ，只要把前面两个return调换即可</span></span><br><span class="line"><span class="comment">// 对于会返回数字的比较函数，记忆：a-b就是a~b，什序，b-a就是b~a，降序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>数组副本连接：concat([ele1,[arr1),不传递参数，只是一个副本，传递参数，在副本末尾添加元素。<br>数组副本截断：slice(star, end),返回从开始到结束位置之间的项<br>数组删除、插入、替换：<strong>始终返回的是被删除项的数组</strong>。<br>删除:splice(开始的位置, 删除的项数)<br>插入:splice(开始的位置, 0, 元素1,元素2),跟删除一样，只是删除的项数是0，不删除直接添加。<br>替换:splice(开始的位置，删除项数，元素1，元素2)，跟删除一样，只是删除后再添加。</p>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>查找索引: indexOf(要找的元素，[起点位置),返回查找项在数组中的位置，找不到则返回-1。<br>lastIndexOf,从数组末尾开始向前找。</p>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>5个迭代方法：都接收两个参数，(fn(当前值item，当前索引index，数组本身array), [函数的作用域对象)<br>every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则<strong>返回true</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>filter():对数组中的每一项运行给定函数，<strong>返回该函数会返回true 的项组成的数组</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure></p>
<p>forEach():对数组中的每一项运行给定函数，没有返回值<br>map():对数组中的每一项运行给定函数，<strong>返回每次函数调用的结果组成的数组。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure></p>
<p>some():对数组中的每一项运行给定函数，<strong>如果该函数对任一项返回true，则返回true。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p><code>reduce(fn(前一个值，当前值，当前索引，数组本身), )</code>:迭代数组的所有项，然后构建一个最终返回的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure></p>
<p><code>reduceRight()</code>，跟<code>reduce</code>一样，只是从最后一项开始。</p>
<h1 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h1><ol>
<li><p>Date类型使用自UTC（Coordinated Universal Time，国际协调时间）1970 年1 月1 日午夜（零时）开始经过的毫秒数来保存日期。</p>
</li>
<li><p>要创建一个日期对象，使用new 操作符和Date 构造函数即可。在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。</p>
</li>
<li><p>为了简化上述的毫秒，ES提供两个方法对日期进行计算，<code>Date.parse()</code>,<code>Date.UTC()</code>.</p>
</li>
<li><p><code>Date.parse()</code>，可用的时间格式：<br>“月/日/年”<br>“英文月 日，年”<br>“ISO 8601 YYYY-MM-DDTHH:mm:ss”<br>例如：<br><code>var someDate = new Date(Date.parse(&quot;2018-11-19T15:12:55&quot;))</code><br><code>var loveDay = new Date(&quot;11/18/2018&quot;);</code><br>直接将表示日期的字符串传递个构造函数也会默认调用parse方法</p>
</li>
<li><p><code>Date.UTC(年，月，日，小时，分钟，秒)</code>，只有年月是必须的，其他如果省略则默认是0。尽管你给定了一个时间值，编译器会自动采用本地时区。所以少用吧。了解就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> love = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">8</span>, <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="comment">//Sun Nov 18 2018 16:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>日期的get和set</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> love = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2018-11-27T17:30:01"</span>);</span><br><span class="line"><span class="comment">// get 获取年月日不需要复数，时间需要复数</span></span><br><span class="line">love.getFullYear(); <span class="comment">// 2018 都是number类型</span></span><br><span class="line">love.getMonth(); <span class="comment">// 10 对月份是从0开始算起</span></span><br><span class="line">love.getDate(); <span class="comment">// 27 表示这个月的第几天</span></span><br><span class="line">love.getHours(); <span class="comment">// 17</span></span><br><span class="line">love.getMinutes(); <span class="comment">// 30</span></span><br><span class="line">love.getSeconds(); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// set 只是将前缀换成set，并赋值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h1><ol>
<li><p>创建一个正则表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /pattern/flags</span></span><br><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/love [ui]/g</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元字符:在正则表达式中有特殊用途，如果要使用这些字符就要进行转义<br><code>( [ { \ ^ $ | ) ? * + .]}</code></p>
</li>
<li><p>RegExp实例属性<br><code>global</code>：boolean, if set flags of g<br><code>ignoreCase</code>: boolean, if set flags of i<br><code>lastIndex</code>: number, the next items’ index of start，from zero to run.<br><code>source</code>: the RegExp’s string.</p>
</li>
<li><p>RegExp实例方法<br><code>exec(string)</code>，design for the capture group and the string is applying the pattern.It returns a Array and contains two attrib:index and input.index表示第一个匹配项出现在字符串的位置。input则表示string。当出现两个以上则没有这两个属性。<br>在数组中，第一项是与整个模式匹配的字符串，其他项则是捕获组匹配到的字符串。如果没有捕获组，则数组只包含一项。在全局匹配模式下，lastIndex 的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。也就是说设置了g，则每一次调用exec都会在字符串中继续查找新匹配项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">// 0</span></span><br><span class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line">aler t(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>test(string)</code>,返回boolean，表示是否与模式与字符串匹配。经常用于if语句中，用于验证用户输入。</p>
<h1 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h1><ol>
<li><p>函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。这就是JS函数没有重载的原因。</p>
</li>
<li><p>声明函数的方式有三种：<br>通常用函数声明语法：<code>function sum(a, b) {return a + b;}</code><br>也常用函数表达式定义函数：<code>var sum = function(a, b) {return b}</code><br>虽然可以，但不要用Function构造函数<code>var sum = new Function(a, b)</code>。这其实也说明了，函数就是对象。</p>
</li>
<li><p>没有重载，因为是函数名指针，函数名相同，则表示同一个指针，后者覆盖前者。</p>
</li>
<li><p>函数声明和函数表达式区别：<strong>函数声明有一个<em>函数声明提升的过程（类似变量提升）</em>，而函数表达式没有这个过程</strong>。这个重要的区别，让函数声明可以在调用后才进行初始化，而函数表达式不行。</p>
</li>
<li><p>函数内部属性：arguments和this。arguments就是参数的意思，是一个类数组对象。this引用的是函数执行的环境对象。</p>
</li>
<li><p>函数属性和方法</p>
</li>
<li>属性：length和prototype，length表示函数希望接收的参数个数，prototype上文解释。</li>
<li>方法：apply(参数数组)和call(参数列表),bind(obj),返回一个函数实例。参考上文解释。</li>
</ol>
<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><ol>
<li><p>3个特殊的引用类型：Boolean、Number 和String。</p>
</li>
<li><p>每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
</li>
<li><p>原理：为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ol>
<li><p>Number类型上文有提到，Boolean很简单不必写。重点在String。因为我们常常需要对字符串进行操作。</p>
</li>
<li><p><code>charAt(n)</code>n位置的字符（简单方式：像数组一样使用[]访问）,<code>charCodeAt(n)</code>n位置的字符的编码。</p>
</li>
<li><p>字符串操作方法<br><code>concat(str1, str2...)</code>拼接多个字符串，返回新的字符串。(应该更多的使用+)<br><code>slice(start，end)</code>截断字符串，返回新的子字符串。<br><code>substr(start, length)</code>，同样是截断字符串，跟slice的区别在于，第二个参数是指长度，返回新的子字符串。</p>
</li>
<li><p>字符串位置方法<br><code>indexOf(str),lastIndexOf(str)</code>，返回子字符串的索引。</p>
</li>
<li><p>删除空格<br><code>trim(),trimLeft(),trimRight()。</code>返回去掉空格后的新字符串。</p>
</li>
<li><p>大小写转化<br><code>toLowerCase(), toUppercase()</code></p>
</li>
<li><p>字符串的模式匹配<br><code>match(pattern)</code>,在字符串上调用这个方法与在正则表达式中调用exec方法基本是一样的。返回的是一个数组。区别在于，exec每次只是返回一项，而match返回所有项。<br><code>search(pattern)</code>,返回第一个匹配项的索引。</p>
</li>
<li><p>替换字符串<br><code>replace(pattern|oldString, newString|fn)</code><br>如果第一个参数是一个字符串，则只会替换第一个字符串。提供正则+g则可以替换所有子字符串。</p>
</li>
<li><p>分隔字符串<br><code>split(str|pattern)</code>,基于指定的分隔符将一个字符串分割成子字符串，返回一个数组。跟join相反。</p>
</li>
<li><p>编译字符编码：String.fromCharCode(code)</p>
</li>
<li><p>本地字符串大小比较：localeCompare(str); 字符串排在参数前则-1；等于则0；排在参数后则1；</p>
</li>
</ol>
<h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><ol>
<li>由ECMA实现的，不依赖宿主环境的对象那个，在程序执行之前就存在了。</li>
</ol>
<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><ol>
<li><p>所有在全局作用域中定义的属性和函数，都是Global对象的属性。很多可以直接使用的函数实际上就是Global对象的方法，比如：isNaN(),parseInt()。</p>
</li>
<li><p>URI编码方法：<code>encodeURI() encodeURIComponent()</code>区别在于，前者不会对本身属于URI的特殊字符进行编码，比如冒号和斜杠。而后者会对它发现的任何标准字符进行编码。<br>var uri = “<a href="http://www.wrox.com/illegal" target="_blank" rel="noopener">http://www.wrox.com/illegal</a> value.htm#start”;<br>//“<a href="http://www.wrox.com/illegal%20value.htm#start" target="_blank" rel="noopener">http://www.wrox.com/illegal%20value.htm#start</a>“<br>alert(encodeURI(uri));<br>//“http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start”<br>alert(encodeURIComponent(uri));</p>
</li>
<li><p>URI解码方法：<code>decodeURI() decodeURIComponent()</code>分别对应解码上述两者的编码。</p>
</li>
<li><p>eval(执行的代码的字符串),就相当于一个解释器，解析后执行。但很危险，有被代码注入的危险。</p>
</li>
<li><p>在浏览器中，实际上window就是全局对象。</p>
</li>
</ol>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><ol>
<li><p>最大最小值,<code>max() min()</code>,寻找数组的最大最小值<code>Math.max.apply(Math, [1, 2, 5, 8])</code></p>
</li>
<li><p>舍入方法，<code>ceil() floor() round()</code> 向上取整，向下取整 四舍五入</p>
</li>
<li><p>随机数，random()返回大于等于0小于1的随机数。<br>获取某个范围内的整数。Math.floor(random()*可能值的总数 + 第一个可能的值)</p>
</li>
<li><p>其他数学操作：<code>abs(num) pow(num,power) sqrt(num)</code></p>
</li>
</ol>
<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><ol>
<li><p>闭包的概念：有权访问另一个函数作用域中的变量的函数。闭包即函数。不要把这个概念复杂化了，闭包就是一个可访问另一个函数中的变量的函数。</p>
</li>
<li><p>闭包和变量：<strong>闭包所保存的是整个变量对象，而不是特殊的变量。</strong>想象中，应该是每个函数都返回不同的i，但实际上都返回10.因为每个函数的作用域链中保存着相同的createFunctions()函数的活动对象，所以它们引用的是同一个变量i。当createFunction函数返回后，i的值是10.此时每个函数都引用着保存变量i的同一个变量对象，所以每个函数都返回10.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解决方案：没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组由于函数参数是按值传递的，所以就会将变量i 的当前值复制给参数num.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>关于this对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure></li>
</ol>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  标签: 
		  
			<a href="/tags/JavaScript/">JavaScript</a>
		  
		</div>
		
		
		<div class="post-categories">
		  分类: 
		  
			<a href="/categories/前端/">前端</a>
		  
		</div>
				

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/10/28/learn NodeJS/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Node.js语言编程</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/10/28/learn ES6/">
        <span class="next-text nav-default">ES6语言编程</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

		<div id="comment"></div>
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
		<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
	<script>
		new Valine({
			el: '#comment',
			notify:false, 
			verify:false, 
			appId: 'jzIDVrftjWXBnBBQ69gkvxur-gzGzoHsz',
			appKey: 'xJDA1U3tIhTEhtKd1QY5w6Cd',
			notify: true, // 邮件提醒!!!
			verify: true, // 验证码			
			placeholder: '说出你的想法！如果你想尽快得到回复的话，请在上方填写你的邮箱和昵称~ヾﾉ≧∀≦)o',
			path:window.location.pathname, 
			avatar:'mm' 
		});
	</script>
    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2018
    <span class="footer-author">Janro-Cheung.</span>
    <span class="power-by">
        Use <a class="hexo-link" href="https://hexo.io/">Hexo</a> By<a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear"> polarbear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">回到顶部
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
